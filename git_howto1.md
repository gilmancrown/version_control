# Подсказки по Git

## Создание репозитория

Теперь вы готовы к работе с Git локально на компьютере.
Создадим наш первый репозиторий. Для этого пройдите в папку вашего проекта.

```

#Для Linux и MacOS путь может выглядеть так /Users/UserName/Desktop/MyProject
#Для Windows например С://MyProject
cd <путь_к_вашему_проекту>

#Инициализация/создание репозитория
git init
```
Теперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий, в нем нет вашего кода. Для этого необходимо создать commit.

```
#Добавим все файлы проекта в нам будующий commit
git add .
#Или так
git add --all

#Если хотим добавить конкретный файл то можно так
git add <имя_файла> 

#Теперь создаем commit. Обязательно указываем комментарий.
#И не забываем про кавычки
git commit -m "<комментарий>"
```
Отлично. Вы создали свой первый репозиторий и заполнили его первым commit.

## Проверка статуса репозитория

Просмотреть статус нужного репозитория можно по ключевому слову status: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.
```sh
git status
```

## Просмотр истории коммитов с изменениями

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в каждый файл.
```sh
git log -p
```

## Просмотр изменений до коммита

Можно просматривать список изменений, внесённых в репозиторий, используя параметр diff. По умолчанию отображаются только изменения, не подготовленные для фиксации.
```sh
git diff
```

## Отмена подготовленных и неподготовленных изменений

Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром checkout. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр git checkout изменит указатель HEAD, чтобы задать указанную ветку как текущую.
```sh
git checkout somefile.js
```
## Игнорирование в Git

Git рассматривает каждый файл в вашей рабочей копии как файл одного из трех нижеуказанных типов.

1. Отслеживаемый файл — файл, который был предварительно проиндексирован или зафиксирован в коммите.

2. Неотслеживаемый файл — файл, который не был проиндексирован или зафиксирован в коммите.

3. Игнорируемый файл — файл, явным образом помеченный для Git как файл, который необходимо игнорировать.

Игнорируемые файлы — это, как правило, артефакты сборки и файлы, генерируемые машиной из исходных файлов в вашем репозитории, либо файлы, которые по какой-либо иной причине не должны попадать в коммиты. Вот некоторые распространенные примеры таких файлов:

кэши зависимостей, например содержимое /node_modules или /packages;
скомпилированный код, например файлы .o, .pyc и .class ;
каталоги для выходных данных сборки, например /bin, /out или /target;
файлы, сгенерированные во время выполнения, например .log, .lock или .tmp;
скрытые системные файлы, например .DS_Store или Thumbs.db;
личные файлы конфигурации IDE, например .idea/workspace.xml.
Игнорируемые файлы отслеживаются в специальном файле .gitignore, который регистрируется в корневом каталоге репозитория. В Git нет специальной команды для указания игнорируемых файлов: вместо этого необходимо вручную отредактировать файл .gitignore, чтобы указать в нем новые файлы, которые должны быть проигнорированы. Файлы .gitignore содержат шаблоны, которые сопоставляются с именами файлов в репозитории для определения необходимости игнорировать эти файлы.

## Git branch

Здесь описывается команда git branch и рассматривается общая модель ветвления в Git. Возможность ветвления доступна в большинстве современных систем контроля версий. Однако эта операция в ряде систем может быть довольно затратной как по времени, так и по объему дискового пространства. Команда git branch позволяет создавать, просматривать, переименовывать и удалять ветки. Она не дает возможности переключаться между ветками или выполнять слияние разветвленной истории. Именно поэтому команда git branch тесно связана с git checkout и git merge. По сути, они представляют собой указатель на снимок изменений. Если нужно добавить новую возможность или исправить баг (незначительный или серьезный), вы создаете новую ветку, в которой будут размещаться эти изменения. Объединить нестабильный код с основной базой кода становится сложнее, к тому же перед слиянием с основной веткой можно очистить историю работы над возможностью, Git предлагает облегченную реализацию веток по сравнению с другими системами контроля версий. Вместо того чтобы копировать файлы из каталога в каталог, Git хранит ветку в виде ссылки на коммит. Получается, что ветка представляет собой вершину серии коммитов, а не контейнер для коммитов. История ветки распространяется через иерархические отношения с другими коммитами.

## Git merge

Слияние используется в Git, чтобы собрать воедино разветвленную историю. Команда git merge выполняет слияние отдельных направлений разработки, созданных с помощью команды git branch, в единую ветку.

Обратите внимание: все приведенные ниже команды выполняют слияние в текущую ветку, а в то время как целевая ветка остается без изменений. Поэтому команда git merge часто используется в сочетании с командами git checkout (для выбора текущей ветки) и git branch -d (для удаления устаревшей целевой ветки).

Команда git merge объединяет несколько последовательностей коммитов в общую историю. Чаще всего команду git merge используют для объединения двух веток. Этот вариант слияния рассматривается в следующих примерах. В таких случаях команда git merge принимает два указателя на коммиты (обычно последние в ветке) и находит общий для них родительский коммит. Затем Git создает коммит слияния, в котором объединяются изменения из обеих последовательностей, выбранных к слиянию.

# Удалённый репозиторий

В предыдущих разделах мы использовали Git локально на компьютере. Теперь нам нужна удалённая версия репозитория, которой мы сможем поделиться с другими разработчиками или использовать в качестве резервного хранилища для проекта. Создать удалённый репозиторий можно на разных платформах, среди которых популярны сервисы GitHub и GitLab. Мы будем работать с GitHub.

Для работы с GitHub вам нужно зарегистрироваться и настроить SSH-ключи для безопасного соединения. После можно переходить к удалённому репозиторию.

git remote add origin url: привязка локального и удалённого репозитория
С помощью командной строки переместитесь в папку с проектом на своём компьютере. Теперь вы можете выполнить команду git remote add, которая установит связь между вашим локальным и удалённым репозиторием на GitHub.

К команде нужно добавить два параметра: имя вашего удалённого репозитория и его адрес. Адрес вы найдёте на странице своего профиля во вкладке SSH.

# Перемещение в папку с проектом
cd путь/к/папке/с/проектом

# Привязка локального репозитория к удалённому на GitHub
git remote add origin git@github.com:ваш_профиль/ваш_репозиторий.git
git remote: просмотр удалённых репозиториев
Если вы часто взаимодействуете с GitHub, то с вашим локальным может быть связано множество удалённых репозиториев. Если ввести команду git remote, то можно посмотреть название этих репозиториев и отсортировать все ненужные.

# Запрашиваем список удалённых репозиториев, которые связаны с локальным
git remote

# Пример вывода: два удалённых репозитория связаны с нашим локальным
  origin
  upstream
git remote — v: просмотр удалённых URL-адресов
Команда git remote показывает только названия удалённых репозиториев, которые связаны с вашим локальным. К команде можно добавить опцию -v и посмотреть удалённые URL-адреса. По URL-адресам будет видно, какие изменения вы делали.

# Запрос списка удалённых репозиториев с URL-адресами
git remote -v

# Пример вывода с URL-адресами
  origin  https://github.com/user/repo.git (fetch)
  origin  https://github.com/user/repo.git (push)
  upstream  https://github.com/otheruser/repo.git (fetch)
  upstream  https://github.com/otheruser/repo.git (push)
git push: отправка изменений в удалённый репозиторий
Команда git push загружает изменения из локального репозитория в удалённый.

Во время первой загрузки нужно использовать команду с опцией -u. Это свяжет локальную и удалённую ветки и синхронизирует их для последующих операций. Для второй и всех последующих загрузок опция -u для связанных веток не понадобится.

# Команда для первой загрузки изменений в удалённый репозиторий: текущая ветка будет связана с веткой main в удалённом репозитории origin 
git push -u origin main

# Команда для второй и последующих загрузок изменений в удалённый репозиторий 
git push
git pull: получение изменений из удалённого репозитория
Команда git pull скачивает изменения из удалённого репозитория в локальный.

# Скачиваем изменения из удалённого репозитория и добавляем их в локальную ветку
git pull

конец памятки. До свидания.